## Data Modeling

## Name 3 advantages to Test Driven Development

1. Better program design and higher code quality

When writing tests, programmers first have to define a goal they will achieve with the code piece. Developers estimate an experience it will give and the way it will match with other pieces of the entire code. A developer keeps in mind everything, from an interface to a work plan.

2. Detailed project documentation

When writing tests for particular requirements, programmers immediately create a strict and detailed specification. It already includes all the likely users’ actions.

3. Code flexibility and easier maintenance
When writing code, developers strive to get fewer bugs, which considerably influences business spending.

According to the IEEE Software publication, implementation of Test Driven Development reduces the percentage of bugs by 40 - 80 percent, which consequently means that less time is required for fixing them.

## In what case would you need to use beforeEach() or afterEach() in a test suite?
If you have some work you need to do repeatedly for many tests, you can use beforeEach and afterEach.

beforeEach() is run before each test in a describe
afterEach() is run after each test in a describe

## What is one downside of Test Driven Development
* slow process 

If you begin TDD, you’ll get the sensation that you simply need an extended duration of your time for straightforward implementations. you would like to believe the interfaces, write the test code, and run the tests before you’ll finally start writing the code.

## What’s the primary difference between ES6 Classes and Constructor/Prototype Classes?

The class contains the Constructors and Functions. The Constructors take responsibility for allocating memory for the objects of the class. The function takes the responsibility of the action of the objects. Combing these two Constructor and Function to make the Class. 
In the ES6 to create any class, you need to use the class keyword.

## Why REST?

REST aims to make caching easier. Since the server is stateless and each request can be processed individually, GET requests should usually return the same response regardless of previous ones and the session. This makes the GET requests easily cacheable and browsers usually treat them as such.

---------------------------


